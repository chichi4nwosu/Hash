/*


Lab 2 – HashSet (Chaining)

OBJECTIVE

Write a generic ChainHash class, using chaining, that has the property that no duplicate items are
allowed. Your chains should be made up of HashNode objects. Implement the same methods and
constructors as Lab 1. Load, compile, and run the same HashSetTester.java to test the
ChainHash class.
void rehash()
int hashFunction(E value)
boolean add(E value) – Use the info on the page before to complete this.
boolean contains(E value)
int length()
boolean isEmpty()
boolean remove(E value)
int size()
String toString()
 */

import java.util.Vector;
import java.util.Collection;

    
    public class ChainingHash<E> implements Hash<E> {
        private Vector<HashNode<E>> hashTable;
        private int capacity;
        private int size;
        private final double LF_THRESHOLD = 0.75;

        public ChainingHash(int capacity) {
        	this.capacity = 0;
        	this.size = 0;
            this.hashTable = new Vector<>(capacity);
            for (int i = 0; i < capacity; i++) {
                hashTable.add(null);
            }
        }
        public ChainingHash() {
            this.capacity = 10;
            this.size = 0;
            this.hashTable = new Vector<>(capacity);
            for (int i = 0; i < capacity; i++) {
                hashTable.add(null);
            }
        }
        
        public ChainingHash(Collection<E> list) {
            this();
            for (E element : list) {
                add(element);
            }
        }

         
        public int length() {
            return capacity;
        }

         
        public int size() {
            return size;
        }

         
        public boolean isEmpty() {
            return size() == 0;
        }
        
         
        public boolean add(E value) {
            int index = hashFunction(value);
            HashNode<E> head = hashTable.get(index);
            HashNode<E> newNode = new HashNode<>(value, null);

            if (head == null) {
                hashTable.set(index, newNode);
                return true;
            }

            HashNode<E> prev = null;
            while (head != null) {
                if (head.getValue().equals(value)) {
                    return false; // Duplicate found, do not add
                }
                prev = head;
                head = head.getNext();
            }
            prev.setNext(newNode);
            size++;
            return true;
        }

    public void rehash() {
        int newCapacity = capacity * 2; // Double the capacity
        
        Vector<HashNode<E>> oldTable = hashTable; // Store reference to old table
        hashTable = new Vector<>(newCapacity); // Create new table with doubled capacity
        
        // Initialize new table with null nodes
        for (int i = 0; i < newCapacity; i++) {
            hashTable.add(null);
        }
        
        // Rehash all elements from the old table into the new table
        for (HashNode<E> oldNode : oldTable) {
            while (oldNode != null) {
                add(oldNode.getValue()); // Add each element to the new table
                oldNode = oldNode.getNext();
            }
        }
        
        capacity = newCapacity; // Update capacity
    }
        
        private int hashFunction(E value) {
            return Math.abs(value.hashCode() % capacity);
        }
         
        public boolean contains(E value) {
            int index = hashFunction(value);
            HashNode<E> head = hashTable.get(index);

            while (head != null) {
                if (head.getValue().equals(value)) {
                    return true;
                }
                head = head.getNext();
            }
            return false;
        }

         
        public boolean remove(E value) {
            int index = hashFunction(value);
            HashNode<E> head = hashTable.get(index);
            HashNode<E> prev = null;

            while (head != null) {
                if (head.getValue().equals(value)) {
                    if (prev == null) {
                        hashTable.set(index, head.getNext());
                    } else {
                        prev.setNext(head.getNext());
                    }
                    size--;
                    return true;
                }
                prev = head;
                head = head.getNext();
            }
            return false; // Element not found
        }

         
        public String toString() {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < hashTable.size(); i++) {
                sb.append("[").append(i).append("]: ");
                HashNode<E> node = hashTable.get(i);
                while (node != null) {
                    sb.append(node.getValue()).append(" ");
                    node = node.getNext();
                }
                sb.append("\n");
            }
        return sb.toString();

    
}
    }
